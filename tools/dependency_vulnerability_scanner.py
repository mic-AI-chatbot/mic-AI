import logging
import os
import subprocess  # nosec B404
import json
from datetime import datetime
from typing import List, Dict, Any, Optional
from tools.base_tool import BaseTool

logger = logging.getLogger(__name__)

class DependencyVulnerabilityScannerTool(BaseTool):
    """
    A tool for scanning project dependencies for known vulnerabilities using
    various package managers (pip, npm, cargo).
    """

    def __init__(self, tool_name: str = "dependency_vulnerability_scanner"):
        super().__init__(tool_name)
        self.scans_file = "vulnerability_scans.json"
        self.scans: Dict[str, Dict[str, Any]] = self._load_scans()

    @property
    def description(self) -> str:
        return "Scans project dependencies for known vulnerabilities using pip, npm, or cargo, and generates scan reports."

    @property
    def parameters(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "operation": {
                    "type": "string",
                    "description": "The vulnerability scanning operation to perform.",
                    "enum": ["scan_project", "get_vulnerability_details", "list_scans"]
                },
                "project_path": {"type": "string", "description": "Absolute path to the project directory."},
                "package_manager": {"type": "string", "enum": ["pip", "npm", "cargo"]},
                "vulnerability_id": {"type": "string"}
            },
            "required": ["operation"]
        }

    def _load_scans(self) -> Dict[str, Dict[str, Any]]:
        if os.path.exists(self.scans_file):
            with open(self.scans_file, 'r') as f:
                try:
                    return json.load(f)
                except json.JSONDecodeError:
                    logger.warning(f"Corrupted scans file '{self.scans_file}'. Starting fresh.")
                    return {}
        return {}

    def _save_scans(self) -> None:
        with open(self.scans_file, 'w') as f:
            json.dump(self.scans, f, indent=4)

    def _run_command(self, command: List[str], cwd: Optional[str] = None) -> Dict[str, Any]:
        try:
            result = subprocess.run(command, capture_output=True, text=True, check=False, cwd=cwd)  # nosec B603
            if result.returncode != 0:
                logger.error(f"Command failed: {' '.join(command)}\nStdout: {result.stdout}\nStderr: {result.stderr}")
                raise RuntimeError(f"Command failed with exit code {result.returncode}: {result.stderr.strip()}")
            return {"stdout": result.stdout.strip(), "stderr": result.stderr.strip(), "returncode": result.returncode}
        except FileNotFoundError:
            raise FileNotFoundError(f"Command '{command[0]}' not found. Is the package manager/scanner installed and in PATH?")
        except Exception as e:
            raise RuntimeError(f"An unexpected error occurred while running command: {e}")

    def _scan_project(self, project_path: str, package_manager: str) -> Dict[str, Any]:
        if not os.path.isabs(project_path): raise ValueError("Project path must be an absolute path.")
        if not os.path.isdir(project_path): raise FileNotFoundError(f"Project directory not found at '{project_path}'.")

        package_manager = package_manager.lower()
        scan_id = f"SCAN-{package_manager}-{datetime.now().strftime('%Y%m%d%H%M%S')}-{os.urandom(4).hex()}"
        
        command: List[str] = []
        if package_manager == "pip":
            requirements_file = os.path.join(project_path, "requirements.txt")
            if not os.path.exists(requirements_file): raise FileNotFoundError(f"requirements.txt not found in '{project_path}'.")
            try: command = ["pip-audit", "-r", requirements_file]; result = self._run_command(command)
            except FileNotFoundError:
                try: command = ["safety", "check", "-r", requirements_file]; result = self._run_command(command)
                except FileNotFoundError: raise RuntimeError("Neither 'pip-audit' nor 'safety' found. Please install one for pip vulnerability scanning.")
        elif package_manager == "npm": command = ["npm", "audit"]; result = self._run_command(command, cwd=project_path)
        elif package_manager == "cargo": command = ["cargo", "audit"]; result = self._run_command(command, cwd=project_path)
        else: raise ValueError(f"Unsupported package manager: {package_manager}.")

        scan_report = {
            "scan_id": scan_id, "project_path": project_path, "package_manager": package_manager,
            "timestamp": datetime.now().isoformat(), "status": "completed",
            "vulnerabilities_found": "No vulnerabilities detected." if result["returncode"] == 0 else "Vulnerabilities detected.",
            "report_output": result["stdout"], "error_output": result["stderr"]
        }
        self.scans[scan_id] = scan_report
        self._save_scans()
        return scan_report

    def _get_vulnerability_details(self, vulnerability_id: str) -> Optional[Dict[str, Any]]:
        simulated_db = {
            "CVE-2023-1234": {
                "id": "CVE-2023-1234", "description": "Buffer overflow in library X.", "severity": "Critical",
                "affected_versions": ["<1.2.0"], "fix_versions": [">=1.2.0"], "references": ["https://example.com/cve/2023-1234"]
            },
            "CVE-2023-5678": {
                "id": "CVE-2023-5678", "description": "Cross-site scripting (XSS).", "severity": "Medium",
                "affected_versions": ["<2.5.0"], "fix_versions": [">=2.5.0"], "references": ["https://example.com/cve/2023-5678"]
            }
        }
        return simulated_db.get(vulnerability_id)

    def execute(self, operation: str, **kwargs: Any) -> Any:
        if operation == "scan_project":
            return self._scan_project(kwargs.get("project_path"), kwargs.get("package_manager"))
        elif operation == "get_vulnerability_details":
            return self._get_vulnerability_details(kwargs.get("vulnerability_id"))
        elif operation == "list_scans":
            return list(self.scans.values())
        else:
            raise ValueError(f"Invalid operation: {operation}")

if __name__ == '__main__':
    print("Demonstrating DependencyVulnerabilityScannerTool functionality...")
    tool = DependencyVulnerabilityScannerTool()
    
    project_dir = os.path.abspath("test_project_for_scan")
    
    try:
        os.makedirs(project_dir, exist_ok=True)
        requirements_path = os.path.join(project_dir, "requirements.txt")
        with open(requirements_path, "w") as f: f.write("requests==2.28.1\n")

        print("\n--- Scanning Project ---")
        scan_result = tool.execute(operation="scan_project", project_path=project_dir, package_manager="pip")
        print(json.dumps(scan_result, indent=2))

        print("\n--- Getting Vulnerability Details ---")
        cve_details = tool.execute(operation="get_vulnerability_details", vulnerability_id="CVE-2023-1234")
        print(json.dumps(cve_details, indent=2))

    except Exception as e:
        print(f"An error occurred: {e}")
    finally:
        if os.path.exists(project_dir): shutil.rmtree(project_dir)
        if os.path.exists(tool.scans_file): os.remove(tool.scans_file)
        print("\nCleanup complete.")
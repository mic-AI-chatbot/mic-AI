import bandit
from bandit.core import manager as b_manager
from bandit.core import config as b_config
from bandit.core import constants as b_constants
import json
import os
import tempfile
import logging
from typing import Union, List, Dict, Any

from tools.base_tool import BaseTool

logger = logging.getLogger(__name__)

class SecurityVulnerabilityScannerTool(BaseTool):
    """
    A tool for scanning Python code for security vulnerabilities using Bandit.
    """

    def __init__(self, tool_name: str = "SecurityVulnerabilityScanner", **kwargs):
        super().__init__(tool_name=tool_name, **kwargs)

    @property
    def description(self) -> str:
        return "Scans Python code (string, file, or directory) for security vulnerabilities using Bandit."

    @property
    def parameters(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "operation": {"type": "string", "enum": ["scan_code", "scan_file", "scan_directory"]},
                "code": {"type": "string", "description": "The Python code to scan as a string."},
                "file_path": {"type": "string", "description": "Absolute path to the Python file to scan."},
                "dir_path": {"type": "string", "description": "Absolute path to the directory containing Python files to scan."},
                "level": {"type": "string", "enum": ["LOW", "MEDIUM", "HIGH"], "default": "MEDIUM", "description": "Minimum severity level to report."},
                "confidence": {"type": "string", "enum": ["LOW", "MEDIUM", "HIGH"], "default": "MEDIUM", "description": "Minimum confidence level to report."},
                "output_format": {"type": "string", "enum": ["text", "json"], "default": "json"}
            },
            "required": ["operation"]
        }

    def _run_bandit_scan(self, scan_path: str, level: str, confidence: str) -> List[Dict[str, Any]]:
        """Helper to run bandit scan on a given path."""
        # Bandit expects a list of paths, even for a single file
        paths = [scan_path] if os.path.isfile(scan_path) else [scan_path]

        # Configure Bandit
        conf = b_config.BanditConfig()
        b_mgr = b_manager.BanditManager(conf, "custom")
        
        # Suppress Bandit's own logging to avoid clutter
        bandit_logger = logging.getLogger('bandit')
        bandit_logger.setLevel(logging.CRITICAL)

        # Discover files and run tests
        b_mgr.discover_files(paths)
        b_mgr.run_tests()

        # Filter issues by severity and confidence
        sev_level = b_constants.SEVERITY_LEVELS[level.upper()]
        conf_level = b_constants.CONFIDENCE_LEVELS[confidence.upper()]

        results = []
        for issue in b_mgr.get_issue_list(sev_level=sev_level, conf_level=conf_level):
            results.append({
                "filename": issue.fname,
                "test_name": issue.test,
                "test_id": issue.test_id,
                "issue_severity": issue.severity,
                "issue_confidence": issue.confidence,
                "issue_text": issue.text,
                "line_number": issue.lineno,
                "col_offset": issue.col,
            })
        return results

    def _scan_python_code(self, code: str, level: str, confidence: str) -> List[Dict[str, Any]]:
        """Scans a string of Python code."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as tmp:
            tmp.write(code)
            scan_path = tmp.name
        try:
            return self._run_bandit_scan(scan_path, level, confidence)
        finally:
            if os.path.exists(scan_path):
                os.remove(scan_path)

    def _scan_python_file(self, file_path: str, level: str, confidence: str) -> List[Dict[str, Any]]:
        """Scans a Python file."""
        if not os.path.isabs(file_path): raise ValueError("file_path must be an absolute path.")
        if not os.path.exists(file_path): raise FileNotFoundError(f"File not found at {file_path}")
        if not file_path.endswith(".py"): raise ValueError(f"File '{file_path}' is not a Python file.")
        return self._run_bandit_scan(file_path, level, confidence)

    def _scan_python_directory(self, dir_path: str, level: str, confidence: str) -> List[Dict[str, Any]]:
        """Scans all Python files in a directory."""
        if not os.path.isabs(dir_path): raise ValueError("dir_path must be an absolute path.")
        if not os.path.exists(dir_path) or not os.path.isdir(dir_path): raise ValueError(f"Directory not found or is not a directory: {dir_path}")
        
        all_results = []
        for root, _, files in os.walk(dir_path):
            for file in files:
                if file.endswith(".py"):
                    file_path = os.path.join(root, file)
                    try:
                        all_results.extend(self._run_bandit_scan(file_path, level, confidence))
                    except Exception as e:
                        self.logger.error(f"Error scanning file {file_path}: {e}")
        return all_results

    def execute(self, operation: str, output_format: str = "json", **kwargs: Any) -> Any:
        scan_results = []
        try:
            if operation == "scan_code":
                code = kwargs.get('code')
                if not code:
                    raise ValueError("'code' is required for 'scan_code' operation.")
                scan_results = self._scan_python_code(code, kwargs.get('level', 'MEDIUM'), kwargs.get('confidence', 'MEDIUM'))
            elif operation == "scan_file":
                file_path = kwargs.get('file_path')
                if not file_path:
                    raise ValueError("'file_path' is required for 'scan_file' operation.")
                scan_results = self._scan_python_file(file_path, kwargs.get('level', 'MEDIUM'), kwargs.get('confidence', 'MEDIUM'))
            elif operation == "scan_directory":
                dir_path = kwargs.get('dir_path')
                if not dir_path:
                    raise ValueError("'dir_path' is required for 'scan_directory' operation.")
                scan_results = self._scan_python_directory(dir_path, kwargs.get('level', 'MEDIUM'), kwargs.get('confidence', 'MEDIUM'))
            else:
                raise ValueError(f"Invalid operation: {operation}.")

            if not scan_results:
                return {"status": "success", "message": "Scan completed. No issues found."}
            
            if output_format == "json":
                return {"status": "success", "issues_found": scan_results}
            else: # text format
                report_lines = ["--- Security Scan Report ---"]
                for issue in scan_results:
                    report_lines.append(f"File: {issue['filename']} (Line: {issue['line_number']})")
                    report_lines.append(f"  Issue: {issue['issue_text']}")
                    report_lines.append(f"  Severity: {issue['issue_severity']}, Confidence: {issue['issue_confidence']}")
                    report_lines.append(f"  Test: {issue['test_name']} ({issue['test_id']})\n")
                return {"status": "success", "report": "\n".join(report_lines)}
        except Exception as e:
            self.logger.error(f"An error occurred during security scan: {e}")
            return {"status": "error", "message": str(e)}

if __name__ == '__main__':
    print("Demonstrating SecurityVulnerabilityScannerTool functionality...")
    temp_dir = "temp_security_scan_data"
    if os.path.exists(temp_dir): import shutil; shutil.rmtree(temp_dir)
    os.makedirs(temp_dir)
    
    scanner_tool = SecurityVulnerabilityScannerTool(data_dir=temp_dir)
    
    # Create dummy Python files for testing
    dummy_file_path = os.path.join(temp_dir, "vulnerable_code.py")
    with open(dummy_file_path, 'w') as f:
        f.write("""
import os
import subprocess

def run_command(cmd):
    # CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')
    os.system(cmd)

def insecure_hash(password):
    # CWE-327: Use of a Broken or Risky Cryptographic Algorithm
    return hash(password)

def main():
    user_input = input("Enter command: ")
    run_command(user_input)
    print(insecure_hash("mysecret"))

if __name__ == "__main__":
    main()
""")
    
    dummy_safe_file_path = os.path.join(temp_dir, "safe_code.py")
    with open(dummy_safe_file_path, 'w') as f:
        f.write("""
import hashlib

def secure_hash(password):
    return hashlib.sha256(password.encode()).hexdigest()

def main():
    print(secure_hash("mysecret"))

if __name__ == "__main__":
    main()
""")

    try:
        # 1. Scan a string of Python code
        print("\n--- Scanning Python code string ---")
        code_to_scan = "import subprocess; subprocess.call('ls ' + user_input, shell=True)"
        scan_result_code = scanner_tool.execute(operation="scan_code", code=code_to_scan, level="HIGH")
        print(json.dumps(scan_result_code, indent=2))

        # 2. Scan a vulnerable Python file
        print(f"\n--- Scanning vulnerable file: {dummy_file_path} ---")
        scan_result_file = scanner_tool.execute(operation="scan_file", file_path=dummy_file_path, level="MEDIUM")
        print(json.dumps(scan_result_file, indent=2))

        # 3. Scan a directory
        print(f"\n--- Scanning directory: {temp_dir} ---")
        scan_result_dir = scanner_tool.execute(operation="scan_directory", dir_path=temp_dir, level="LOW", output_format="text")
        print(json.dumps(scan_result_dir, indent=2))

    except Exception as e:
        print(f"\nAn error occurred: {e}")
    finally:
        if os.path.exists(temp_dir): import shutil; shutil.rmtree(temp_dir)
        print(f"\nCleaned up temporary directory '{temp_dir}'.")